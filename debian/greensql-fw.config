#!/bin/sh -e

# This file was originally adopted from mydns package.
# January 26, 2008, Yuli

# Source debconf library.
. /usr/share/debconf/confmodule

db_version 2.0
db_capb backup

# Refactored by Philipp Kern <phil@philkern.de>.
# Please keep the case statement in sync with the model.

## The model:
# 0 exit_failure
# 1 mysql_server
#   11 mysql_server == localhost?
#      !> 111
#      => 2
#      111 no_mysql_message
#          => 0
# 2 database
#   => 3
# 3 setup?
#   !> 4
#   => 31
#   31 mysql_root_user
#      => 32
#   32 mysql_root_passwd
#      => 33
#   33 mysql_confirm
#      !> 331
#      => 4
#      331 mismatch
#          => 32
# 4 mysql_user
#   => 5
# 5 mysql_passwd
#   => 6
# 6 exit_success
##

STATE=1

# Break on 0 (exit_failure) and 6 (exit_success).
while [ "$STATE" != 0 -a "$STATE" != 6 ]
do
  case "$STATE" in
  1)
    db_input critical greensql/mysql_server || true
    if db_go
    then
      db_get greensql/mysql_server || true
      if [ ! -z "$RET" ]
      then
        db_set greensql/no_mysql false || true
        STATE=11
      fi
    else
      STATE=0
    fi
  ;;
  11)
    db_get greensql/mysql_server || true
    if [ "x$RET" = "xlocalhost" ]
    then
      if ! grep -A 1 "Package: mysql-server" /var/lib/dpkg/status | \
        grep -q "install ok installed"
      then
        STATE=111
      fi
    fi
    STATE=2
  ;;
  111)
    db_input critical greensql/no_mysql_message || true
    db_go
    db_set greensql/no_mysql true || true
    STATE=0
  ;;
  2)
    db_input critical greensql/database || true
    if db_go
    then
      db_get greensql/database || true
      if [ ! -z "$RET" ]; then STATE=3; fi
    else
      STATE=1
    fi
  ;;
  3)
    db_input critical greensql/setup || true
    if db_go
    then
      db_get greensql/setup || true
      if [ "x$RET" = "xtrue" ]; then STATE=31; else LASTSTATE=3; STATE=4; fi
    else
      STATE=0
    fi
  ;;
  31)
    db_input critical greensql/mysql_root_user || true
    if db_go
    then
      db_get greensql/mysql_root_user || true
      if [ ! -z "$RET" ]; then STATE=32; fi
    else
      STATE=3
    fi
  ;;
  32)
    db_input critical greensql/mysql_root_passwd || true
    if db_go
    then
      db_get greensql/mysql_root_passwd || true
      # Empty root passwords are not allowed - this would be highly insecure
      # anyway.
      if [ ! -z "$RET" ]; then STATE=33; fi
    else
      STATE=31
    fi
  ;;
  33)
    db_input critical greensql/confirm || true
    if db_go
    then
      db_get greensql/confirm || true
      CONFIRM="$RET"
      db_get greensql/mysql_root_passwd || true
      if [ "$RET" != "$CONFIRM" ]
      then
        # Reset both fields
        db_fset greensql/mysql_root_passwd seen false
        db_fset greensql/confirm seen false
        STATE=331
      else
        STATE=4
      fi
    else
      STATE=32
    fi
  ;;
  331)
    db_input critical greensql/mismatch || true
    db_go
    STATE=32
  ;;
  4)
    db_input critical greensql/mysql_user || true
    if db_go
    then
      db_get greensql/mysql_user || true
      if [ ! -z "$RET" ]; then STATE=5; fi
    else
      STATE=3
    fi
  ;;
  5)
    db_input critical greensql/mysql_passwd || true
    if db_go
    then
      db_get greensql/mysql_passwd || true
      # Again the password could not be left empty out of security reasons.
      if [ ! -z "$RET" ]; then STATE=6; fi
    else
      STATE=4
    fi
  ;;
  esac
done

# 0 is exit_failure
if [ "$STATE" = 0 ]; then exit 1; fi

# vim:set et ts=2:
